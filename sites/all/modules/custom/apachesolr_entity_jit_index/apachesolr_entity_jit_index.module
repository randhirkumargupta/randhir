<?php

/**
 * @file
 * The apache solr entity Just in time index.
 *
 * Contains functionality related to Entity Just in Time Index.
 */

/**
 * Implements hook_menu().
 *
 * {@inheritdoc}
 */
function apachesolr_entity_jit_index_menu() {

  $items['admin/config/search/apachesolr/solr-index-content-type'] = array(
    'title' => 'Solr Index Content type Configuration',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('apachesolr_entity_jit_index_entity_form'),
    'access arguments'   => array('administer search'),
    'type' => MENU_LOCAL_TASK,
  );

  return $items;
}

/**
 * Implements apachesolr_entity_jit_index_entity_form().
 */
function apachesolr_entity_jit_index_entity_form() {
  // Make array for content type.
  foreach (node_type_get_names() as $key => $value) {
    $content_types[$key] = ucwords($value);
  }

  $form['apachesolr_entity_jit_index_for_solr_index'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Select Content type'),
    '#description' => t('Please select content type to which you want to index on update/insert.'),
    '#options' => $content_types,
    '#required' => TRUE,
    '#states' => array(
      'visible' => array(
        ':input[name="solr_entity_use_config[yes]"]' => array('checked' => TRUE),
      ),
    ),
    '#default_value' => variable_get('apachesolr_entity_jit_index_for_solr_index', array()),
  );

  return system_settings_form($form);
}

/**
 * Implements hook_entity_insert().
 *
 * {@inheritdoc}
 */
function apachesolr_entity_jit_index_entity_insert($entity, $type) {
  if ($type == 'node') {
    $content_type = array_values(variable_get('apachesolr_entity_jit_index_for_solr_index'));
    $content_type = array_filter($content_type, function ($a) {
      return ($a !== 0);
    });    
    if (in_array($entity->type, $content_type) && !(($entity->type == 'photogallery' || $entity->type == 'story') && $entity->status == 0)) {
      apachesolr_entity_jit_index_immediately($entity, $type);
    }
  }
}

/**
 * Implements hook_entity_update().
 *
 * {@inheritdoc}
 */
function apachesolr_entity_jit_index_entity_update($entity, $type) {
  if ($type == 'node') {
    $content_type = array_values(variable_get('apachesolr_entity_jit_index_for_solr_index'));
    $content_type = array_filter($content_type, function ($a) {
      return ($a !== 0);
    });
    if (in_array($entity->type, $content_type)) {
      apachesolr_entity_jit_index_immediately($entity, $type);
    }
  } else if ($type == 'taxonomy_term') {
	  if ($entity->vocabulary_machine_name == 'category_management' && in_array(variable_get('program_category_id_for_programmes'), $entity->parent)){
		apachesolr_entity_jit_index_immediately($entity, $type);
	  }
  }
  
}

/**
 * Implements apachesolr_entity_jit_index_immediately().
 *   Helper function to send entities to apachesolr for immediate index.
 */
function apachesolr_entity_jit_index_immediately($entity, $type) {
  // Don't index unpublished entities.
  $env_id = apachesolr_default_environment();
  $bundles_to_index = apachesolr_get_index_bundles($env_id, $type);

  // Check if entity should be indexed.
  $info = entity_get_info($type);
  if (!empty($info['entity keys']['bundle'])) {
    $bundle = $entity->{$info['entity keys']['bundle']};
  }
  else {
    $bundle = $type;
  }

  if (!in_array($bundle, $bundles_to_index) && !($type == 'taxonomy_term' && $entity->vocabulary_machine_name == 'category_management' && in_array(variable_get('program_category_id_for_programmes'), $entity->parent))) {
    return;
  }

  // Entity should be indexed, so send it to solr.
  $ids = entity_extract_ids($type, $entity);
  $id = $ids[0];
  
  if ($type == 'taxonomy_term' && $entity->vocabulary_machine_name == 'category_management') {
	$entity->status = 1;
  }  
  // If this entity is unpublished, remove from index.
  if ($entity->status != 1) {
    apachesolr_remove_entity($env_id, $type, $id);
    return;
  }

  $item = new stdClass();
  $item->entity_id = $id;
  $item->entity_type = $type;
  $item->bundle = $bundle;
  $item->status = $entity->status;

  // Reset the static cache, to get the latest changes.
  entity_get_controller($type)->resetCache(array($id));

  module_load_include('inc', 'apachesolr', 'apachesolr.index');
  if (function_exists('apachesolr_index_entity_to_documents')) {
    $doc = apachesolr_index_entity_to_documents($item, $env_id);
    //watchdog("Entity Update Solr", "<pre> ".print_r($doc, true)."</pre>");
    apachesolr_index_send_to_solr($env_id, $doc);
  }
}


function apachesolr_entity_jit_index_apachesolr_entity_info_alter(&$entity_info) {
  $entity_info['taxonomy_term']['indexable'] = TRUE;
  $entity_info['taxonomy_term']['status callback'] = 'apachesolr_entity_jit_index_status_callback';
  $entity_info['taxonomy_term']['document callback'][] = 'apachesolr_entity_jit_index_solr_document';
  $entity_info['taxonomy_term']['reindex callback'] = 'apachesolr_entity_jit_index_solr_reindex';
  $entity_info['taxonomy_term']['index_table'] = 'apachesolr_index_entities_term';
}

/**
 * Status callback for ApacheSolr, for terms.
 */
function apachesolr_entity_jit_index_status_callback($term, $type) {
  return TRUE;
}

/**
 * Builds the user-specific information for a Solr document.
 *
 * @param ApacheSolrDocument $document
 *   The Solr document we are building up.
 * @param stdClass $entity
 *   The entity we are indexing.
 * @param string $entity_type
 *   The type of entity we're dealing with.
 */
function apachesolr_entity_jit_index_solr_document(ApacheSolrDocument $document, $term, $entity_type) {

  $document->tid = $term->tid;

  // Title is a required field.
  $document->label = apachesolr_clean_text(format_username($term));

  $term_tree = apachesolr_entity_jit_index_solr_taxonomy_ancestors($term);
  foreach ($term_tree as $tt => $td) {
    $document->addField($td['key'], apachesolr_clean_text($td['value']));
  }

  // Note the conspicuous lack of password hash. :-)
  $build = taxonomy_term_view($term, 'search_index');

  // Why do we need this?
  unset($build['#theme']);
  $text = drupal_render($build);

  $document->content = apachesolr_clean_text($text);
  //  Generic usecase for future reference. Callbacks can
  //  allow you to send back multiple documents
  $documents = array();
  $documents[] = $document;
  return $documents;

}

/**
 * Reindexing callback for ApacheSolr, for taxonomy terms.
 */
function apachesolr_entity_jit_index_solr_reindex() {

  $indexer_table = apachesolr_get_indexer_table('taxonomy_term');
  $transaction = db_transaction();
  $env_id = apachesolr_default_environment();
  try {
    db_delete($indexer_table)
      ->condition('entity_type', 'taxonomy_term')
      ->execute();

    $select = db_select('taxonomy_term_data', 't');
    $select->innerJoin('taxonomy_vocabulary', 'v', 't.vid = v.vid');

    $select->addField('t', 'tid', 'entity_id');
    $select->addField('v', 'machine_name', 'bundle');
    $select->addExpression(1, 'status');
    $select->addExpression("'taxonomy_term'", 'entity_type');
    $select->addExpression(REQUEST_TIME, 'changed');

    $select->condition('v.machine_name', apachesolr_get_index_bundles($env_id, 'taxonomy_term'), 'IN');

    $insert = db_insert($indexer_table)
      ->fields(array('entity_id', 'bundle', 'status', 'entity_type', 'changed'))
      ->from($select)
      ->execute();
  }
  catch (Exception $e) {
    $transaction->rollback();
    //drupal_set_message($e->getMessage(), 'error');
    watchdog_exception('Apache Solr', $e);
    return FALSE;
  }

  return TRUE;

}

function apachesolr_entity_jit_index_solr_taxonomy_ancestors($term) {
  static $ancestors = array();

  $vocab_names = array();
  if (!isset($ancestors[$term->tid])) {
    $ancestors[$term->tid] = taxonomy_get_parents_all($term->tid);
  }
  foreach ($ancestors[$term->tid] as $ancestor) {
    // Index parent term against the field. Note that this happens
    // regardless of whether the facet is set to show as a hierarchy or not.
    // We would need a separate field if we were to index terms without any
    // hierarchy at all.

    $fields[] = array(
      'key' => 'tid',
      'value' => $ancestor->tid,
    );
    $fields[] = array(
      'key' => 'im_vid_' . $ancestor->vid,
      'value' => $ancestor->tid,
    );
    $name = apachesolr_clean_text($ancestor->name);
    $vocab_names[$ancestor->vid][] = $name;
    // We index each name as a string for cross-site faceting
    // using the vocab name rather than vid in field construction .
    $fields[] = array(
      'key' => 'sm_vid_' . apachesolr_vocab_name($ancestor->vid),
      'value' => $name,
    );
  }

  foreach ($vocab_names as $vid => $names) {
    $fields[] = array(
      'key' => 'tm_vid_' . $vid . '_names',
      'value' => implode(' ', $names),
    );
  }
  return $fields;
}


/**
 * Implements apachesolr_entity_jit_index_apachesolr_index_document_build().
 * {@inheritdoc}
 */
function apachesolr_entity_jit_index_apachesolr_index_document_build(ApacheSolrDocument $document, $entity, $entity_type, $env_id) {
  if ($entity_type == 'taxonomy_term' && $entity->vocabulary_machine_name == 'category_management') {
	$document->addField('ds_changed', apachesolr_date_iso(time()));
  }
}
